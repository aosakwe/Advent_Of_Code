col <- ncol(im)
out <- data.frame(matrix(data = str_sub(alg,1,1), nrow = row + 10, ncol = col + 10 ))
out[6:(row+5),6:(col+5)] <- im
return(out)
}
enhance <- function(im,alg){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,alg)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
return(new_frame)
}
test <- enhance(image,algo)
test2 <- enhance(test,algo)
length(which(test2 == '#'))
##   Data Prep
input <- file("test.txt","r")
algo <- readLines(input,n = 1)
image <- readLines(input)
close(input)
image <- image[which(image != "")]
image <- matrix(data = image, nrow = length(image),ncol = 1)
image <- data.frame(t(sapply( image, function(a) unlist( strsplit( a, "" )))),row.names = NULL)
# Helper functions
sqr2bin <- function(x){
x[x == "."] <- "0"
x[x== "#"] <- "1"
return(paste(paste(x[1,],collapse = ''),paste(x[2,],collapse = ''),paste(x[3,],collapse = ''),collapse = '', sep = ''))
#out <- str_c(x)
#return(out)
}
bin2dec <- function(x){
dec <- 0
for (i in str_length(x):1){
dec <- dec + (2**(str_length(x)-i))*as.numeric(str_sub(x,i,i))
}
return(dec)
}
# Function 1
enlarge <- function(im,alg){
row <- nrow(im)
col <- ncol(im)
out <- data.frame(matrix(data = str_sub(alg,1,1), nrow = row + 10, ncol = col + 10 ))
out[6:(row+5),6:(col+5)] <- im
return(out)
}
pixel_change <- function(im,r,c,algo){
pixels <- im[(r-1):(r+1),(c-1):(c+1)]
pixels <- sqr2bin(pixels)
#need to shift by one because R loooves indices that start by 1 instead of 0
i <- bin2dec(pixels) + 1
return(str_sub(algo,i,i))
}
enhance <- function(im,alg){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,alg)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
return(new_frame)
}
test <- enhance(image,algo)
test2 <- enhance(test,algo)
length(which(test2 == '#'))
# Function 1
enlarge <- function(im,alg,first){
row <- nrow(im)
col <- ncol(im)
out <- data.frame(matrix(data = ifelse(first == TRUE,".",str_sub(alg,1,1)), nrow = row + 10, ncol = col + 10 ))
out[6:(row+5),6:(col+5)] <- im
return(out)
}
pixel_change <- function(im,r,c,algo){
pixels <- im[(r-1):(r+1),(c-1):(c+1)]
pixels <- sqr2bin(pixels)
#need to shift by one because R loooves indices that start by 1 instead of 0
i <- bin2dec(pixels) + 1
return(str_sub(algo,i,i))
}
enhance <- function(im,alg){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,alg)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
return(new_frame)
}
enhance <- function(im,alg,first = TRUE){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,alg,first)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
return(new_frame)
}
test <- enhance(image,algo,TRUE)
test2 <- enhance(test,algo,FALSE)
length(which(test2 == '#'))
enlarge(image)
# Function 1
enlarge <- function(im){
row <- nrow(im)
col <- ncol(im)
out <- data.frame(matrix(data = '.', nrow = row + 10, ncol = col + 10 ))
out[6:(row+5),6:(col+5)] <- im
return(out)
}
##   Data Prep
input <- file("mini_test.txt","r")
algo <- readLines(input,n = 1)
image <- readLines(input)
close(input)
image <- image[which(image != "")]
image <- matrix(data = image, nrow = length(image),ncol = 1)
image <- data.frame(t(sapply( image, function(a) unlist( strsplit( a, "" )))),row.names = NULL)
enlarge(image)
image[<3,]
enlarge(image)[c(1:3,13:15),]
# Function 1
enlarge <- function(im,fill){
row <- nrow(im)
col <- ncol(im)
out <- data.frame(matrix(data = fill, nrow = row + 10, ncol = col + 10 ))
out[6:(row+5),6:(col+5)] <- im
return(out)
}
enhance <- function(im,alg){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,alg,first)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
new_frame[c(1:3,nrow(big_frame):(nrow(big_frame)-2)),] <- pixel_change(big_frame,2,2,algo)
new_frame[,c(1:3,ncol(big_frame):(ncol(big_frame)-2))] <- pixel_change(big_frame,2,2,algo)
return(new_frame)
}
# Helper functions
sqr2bin <- function(x){
x[x == "."] <- "0"
x[x== "#"] <- "1"
return(paste(paste(x[1,],collapse = ''),paste(x[2,],collapse = ''),paste(x[3,],collapse = ''),collapse = '', sep = ''))
#out <- str_c(x)
#return(out)
}
bin2dec <- function(x){
dec <- 0
for (i in str_length(x):1){
dec <- dec + (2**(str_length(x)-i))*as.numeric(str_sub(x,i,i))
}
return(dec)
}
# Function 1
enlarge <- function(im,fill){
row <- nrow(im)
col <- ncol(im)
out <- data.frame(matrix(data = fill, nrow = row + 10, ncol = col + 10 ))
out[6:(row+5),6:(col+5)] <- im
return(out)
}
pixel_change <- function(im,r,c,algo){
pixels <- im[(r-1):(r+1),(c-1):(c+1)]
pixels <- sqr2bin(pixels)
#need to shift by one because R loooves indices that start by 1 instead of 0
i <- bin2dec(pixels) + 1
return(str_sub(algo,i,i))
}
enhance <- function(im,alg,fill = '.'){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,alg,fill)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
new_frame[c(1:3,nrow(big_frame):(nrow(big_frame)-2)),] <- pixel_change(big_frame,2,2,algo)
new_frame[,c(1:3,ncol(big_frame):(ncol(big_frame)-2))] <- pixel_change(big_frame,2,2,algo)
return(new_frame)
}
test <- enhance(image,algo,str_sub(algo,1,1,))
# Function 1
enlarge <- function(im,fill){
row <- nrow(im)
col <- ncol(im)
out <- data.frame(matrix(data = fill, nrow = row + 10, ncol = col + 10 ))
out[6:(row+5),6:(col+5)] <- im
return(out)
}
test <- enhance(image,algo,str_sub(algo,1,1,))
enhance <- function(im,alg,Fill = '.'){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,alg,Fill)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
new_frame[c(1:3,nrow(big_frame):(nrow(big_frame)-2)),] <- pixel_change(big_frame,2,2,algo)
new_frame[,c(1:3,ncol(big_frame):(ncol(big_frame)-2))] <- pixel_change(big_frame,2,2,algo)
return(new_frame)
}
test <- enhance(image,algo,str_sub(algo,1,1,))
enhance <- function(im,alg,fill = '.'){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,fill)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
new_frame[c(1:3,nrow(big_frame):(nrow(big_frame)-2)),] <- pixel_change(big_frame,2,2,algo)
new_frame[,c(1:3,ncol(big_frame):(ncol(big_frame)-2))] <- pixel_change(big_frame,2,2,algo)
return(new_frame)
}
test <- enhance(image,algo,str_sub(algo,1,1,))
str_sub(algo,1,1,)
str_sub(algo,1,1,)
test <- enhance(image,algo,str_sub(algo,1,1))
test
test2 <- enhance(test,algo,str_sub(algo,512,512))
test2
test <- enhance(image,algo,str_sub(algo,1,1))
test2 <- enhance(test,algo,str_sub(algo,1,1))
test2
length(which(test2 == '#'))
##   Data Prep
input <- file("test.txt","r")
algo <- readLines(input,n = 1)
image <- readLines(input)
close(input)
image <- image[which(image != "")]
image <- matrix(data = image, nrow = length(image),ncol = 1)
image <- data.frame(t(sapply( image, function(a) unlist( strsplit( a, "" )))),row.names = NULL)
# Helper functions
sqr2bin <- function(x){
x[x == "."] <- "0"
x[x== "#"] <- "1"
return(paste(paste(x[1,],collapse = ''),paste(x[2,],collapse = ''),paste(x[3,],collapse = ''),collapse = '', sep = ''))
#out <- str_c(x)
#return(out)
}
bin2dec <- function(x){
dec <- 0
for (i in str_length(x):1){
dec <- dec + (2**(str_length(x)-i))*as.numeric(str_sub(x,i,i))
}
return(dec)
}
# Function 1
enlarge <- function(im,fill){
row <- nrow(im)
col <- ncol(im)
out <- data.frame(matrix(data = fill, nrow = row + 10, ncol = col + 10 ))
out[6:(row+5),6:(col+5)] <- im
return(out)
}
pixel_change <- function(im,r,c,algo){
pixels <- im[(r-1):(r+1),(c-1):(c+1)]
pixels <- sqr2bin(pixels)
#need to shift by one because R loooves indices that start by 1 instead of 0
i <- bin2dec(pixels) + 1
return(str_sub(algo,i,i))
}
enhance <- function(im,alg,fill = '.'){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,fill)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
new_frame[c(1:3,nrow(big_frame):(nrow(big_frame)-2)),] <- pixel_change(big_frame,2,2,algo)
new_frame[,c(1:3,ncol(big_frame):(ncol(big_frame)-2))] <- pixel_change(big_frame,2,2,algo)
return(new_frame)
}
test <- enhance(image,algo,str_sub(algo,1,1))
test2 <- enhance(test,algo,str_sub(algo,512,512))
length(which(test2 == '#'))
test2
enhance <- function(im,alg,fill = '.'){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,fill)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
swap <- pixel_change(big_frame,2,2,algo)
new_frame[c(1:3,nrow(big_frame):(nrow(big_frame)-2)),] <- swap
new_frame[,c(1:3,ncol(big_frame):(ncol(big_frame)-2))] <- swap
return(new_frame)
}
test <- enhance(image,algo,str_sub(algo,1,1))
test2 <- enhance(test,algo,str_sub(algo,512,512))
length(which(test2 == '#'))
str_sub(algo,512,512)
test
test <- enhance(image,algo,str_sub(algo,1,1))
enhance <- function(im,alg,fill = '.'){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,fill)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
swap <- pixel_change(big_frame,2,2,algo)
print(swap)
new_frame[c(1:3,nrow(big_frame):(nrow(big_frame)-2)),] <- swap
new_frame[,c(1:3,ncol(big_frame):(ncol(big_frame)-2))] <- swap
return(new_frame)
}
test
test <- enhance(image,algo,str_sub(algo,1,1))
pixel_change <- function(im,r,c,algo){
pixels <- im[(r-1):(r+1),(c-1):(c+1)]
pixels <- sqr2bin(pixels)
#need to shift by one because R loooves indices that start by 1 instead of 0
i <- bin2dec(pixels) + 1
print(i)
return(str_sub(algo,i,i))
}
test <- enhance(image,algo,str_sub(algo,1,1))
pixel_change <- function(im,r,c,algo){
pixels <- im[(r-1):(r+1),(c-1):(c+1)]
pixels <- sqr2bin(pixels)
#need to shift by one because R loooves indices that start by 1 instead of 0
i <- bin2dec(pixels) + 1
return(str_sub(algo,i,i))
}
pixel_change <- function(im,r,c,algo,test = TRUE){
pixels <- im[(r-1):(r+1),(c-1):(c+1)]
pixels <- sqr2bin(pixels)
#need to shift by one because R loooves indices that start by 1 instead of 0
i <- bin2dec(pixels) + 1
if (test){print(i)}
return(str_sub(algo,i,i))
}
enhance <- function(im,alg,fill = '.'){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,fill)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
swap <- pixel_change(big_frame,2,2,algo,TRUE)
new_frame[c(1:3,nrow(big_frame):(nrow(big_frame)-2)),] <- swap
new_frame[,c(1:3,ncol(big_frame):(ncol(big_frame)-2))] <- swap
return(new_frame)
}
test <- enhance(image,algo,str_sub(algo,1,1))
pixel_change <- function(im,r,c,algo,test = FALSE){
pixels <- im[(r-1):(r+1),(c-1):(c+1)]
pixels <- sqr2bin(pixels)
#need to shift by one because R loooves indices that start by 1 instead of 0
i <- bin2dec(pixels) + 1
if (test){print(i)}
return(str_sub(algo,i,i))
}
enhance <- function(im,alg,fill = '.'){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,fill)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
swap <- pixel_change(big_frame,2,2,algo,TRUE)
new_frame[c(1:3,nrow(big_frame):(nrow(big_frame)-2)),] <- swap
new_frame[,c(1:3,ncol(big_frame):(ncol(big_frame)-2))] <- swap
return(new_frame)
}
test <- enhance(image,algo,str_sub(algo,1,1))
pixel_change <- function(im,r,c,algo,test = FALSE){
pixels <- im[(r-1):(r+1),(c-1):(c+1)]
if (test){print(pixels)}
pixels <- sqr2bin(pixels)
#need to shift by one because R loooves indices that start by 1 instead of 0
i <- bin2dec(pixels) + 1
if (test){print(i)}
return(str_sub(algo,i,i))
}
enhance <- function(im,alg,fill = '.'){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,fill)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
swap <- pixel_change(big_frame,2,2,algo,TRUE)
new_frame[c(1:3,nrow(big_frame):(nrow(big_frame)-2)),] <- swap
new_frame[,c(1:3,ncol(big_frame):(ncol(big_frame)-2))] <- swap
return(new_frame)
}
test <- enhance(image,algo,str_sub(algo,1,1))
test <- enhance(image,algo,'.')
pixel_change <- function(im,r,c,algo){
pixels <- im[(r-1):(r+1),(c-1):(c+1)]
pixels <- sqr2bin(pixels)
#need to shift by one because R loooves indices that start by 1 instead of 0
i <- bin2dec(pixels) + 1
return(str_sub(algo,i,i))
}
enhance <- function(im,alg,fill = '.'){
#here: only enhance CURRENT pixels in input image (the infinite pixels is an excuse to make algorithm work)
#run it on dimensions of current image only (and their extremities)
#make a copy of grid to transfer algorith output to
rows <- nrow(im)
cols <- ncol(im)
big_frame <- enlarge(im,fill)
new_frame <- data.frame(big_frame) #apply changes to this graph
for (r in 4:(rows+7)){
for (c in 4:(cols+7)){
new_frame[r,c] <- pixel_change(big_frame,r,c,alg)
}
}
swap <- pixel_change(big_frame,2,2,algo)
new_frame[c(1:3,nrow(big_frame):(nrow(big_frame)-2)),] <- swap
new_frame[,c(1:3,ncol(big_frame):(ncol(big_frame)-2))] <- swap
return(new_frame)
}
test <- enhance(image,algo,'.')
test2 <- enhance(test,algo,str_sub(algo,512,512))
length(which(test2 == '#'))
test
test2
str_sub(algo,512,512)
test <- enhance(image,algo,'.')
test2 <- enhance(test,algo,'#')
length(which(test2 == '#'))
